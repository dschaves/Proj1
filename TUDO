/*

FORMATADO NO PROCESSADOR GEDIT

Nao fomos conservativos na quantidade de memoria utilizada pois consideramos

que 64 MB sera mais que suficiente para tudo.

Aprendemos e utilizamos apontadores por iniciativa propria.

*/





/*DIRECTIVAS DE PREPROCESSAMENTO*/


#include <stdio.h>

#include <string.h>

#include <stdlib.h>

#define NOMES_SIZE 41 

#define BANCOS_MAX 1000 

#define BUFFER_SIZE 256

#define string char*


/*ESTRUTURAS*/

typedef struct

{

	const char nome[NOMES_SIZE];				

	const char referencia[PARAMETROS_MAX];	

	char classificacao;

	int inP;	

	int outP;

	int outV;	

	int outVM;	

	int inV;	

	int inVM;	

/*Num de Parceiros a quem o banco deve 

Num de Parceios a quem o banco emprestou

Valor total que o banco emprestou

Valor total que o banco emprestou a bancos maus

Valor total que o banco deve

Valor total que o banco deve a bancos maus*/

}	banco;





/*PROTOTIPOS*/



void processa_comando(char linha[]);

void comando_a(char linha[]);

void comando_k(char linha[]);

void comando_r(char linha[]);

void comando_e(char linha[]);

void comando_p(char linha[]);

void comando_K(void);

void comando_x(void);	

int relacional[BANCOS_MAX][BANCOS_MAX];			

banco bancos[BANCOS_MAX];

int histograma[MAX_BANCOS];	

int Ntotal;								

int Nbons;								

int flag_actualizacao;												





int main(void)

{	int flag_saida = 0;

	while (flag_saida != 1)

	{	

		char linha[BUFFER_SIZE];

		fgets(linha, BUFFER_SIZE, stdin);

		flag_saida = processa_comando(linha);

	}

	return EXIT_SUCCESS;

}


int processa_comando(char linha[])

{	

	int tamanho = strlen(linha); 	/tamano nao
	linha[tamanho-1] = ' ';
	linha[0] = ' ';	
	string comando = get_parametro(linha);



	if (!(strcmp( "a", comando)))  	/* Ou seja, se "a" == comando*/

		return comando_a(linha);



	else if	(!(strcmp( "k", comando)))

		return comando_k(linha);



	else if	(!(strcmp( "r", comando)))

		return comando_r(linha);



	else if	(!(strcmp( "e", comando)))

		return comando_e(linha);



	else if	(!(strcmp( "p", comando)))

		return comando_p(linha);



	else if	(!(strcmp( "l", comando)))

		return comando_l(linha);



	else if	(!(strcmp( "K", comando)))

		return comando_K(void);



	else if	(!(strcmp( "x", comando)))

		return comando_x(void);



	else

		puts("Comando errado.");

		return 0;

}


int comando_a(string linha)

{

	string nome = get_parametro(linha);

	string ref = get_parametro(linha);

	string classif = get_parametro(linha);

	cria_banco(nome, ref, classif);

	return 0;

}



int comando_k(string linha);

{

	string ref = get_parametro(linha);

	indice = seek_banco(ref);

	despromove_banco(indice);

	return 0;

}

int comando_r(string linha);

{	
	string referencia;

	indice = seek_banco(ref);

	promove_banco(indice);

	return 0;
}

	



int comando_e(string linha)

{

	string ref1 = get_parametro(linha);

	string ref2 = get_parametro(linha);

	string valor0 = get_parametro(linha);

	int valor = ASCII_para_decimal(valor0);

	empresta(ref1, ref2, valor);

	return 0;

}

	

int comando_p(string linha);

{

	string ref1 = get_parametro(linha);

	string ref2 = get_parametro(linha);

	string valor0 = get_parametro(linha);

	int valor = ASCII_para_decimal(valor0);

	amortiza(ref1, ref2, valor);

	return;
}



int comando_l(string linha);
{
	int i;

	for (i = 0; i >= ; i++)
	{
		print_caracteristicas(	

}


int comando_K();

{

	int i = despromove_pior(); /*Simultaneamente despromove o pior e devolve o seu indice*/

	print_caracteristicas(i);

	return 0;

}







void comando_x()



{ 	flag_saida = 1;

	printf("%d %d", Ntotal, Nbons);

	return;

}	


void cria_banco(char nome[], int referencia, int classificacao)



{



	banco novo_banco;

	novo_banco.nome = nome;

	novo_banco.referencia = referencia;

	novo_banco.classificacao = classificacao;

	index_bancos[Ntotal] = novo_banco

	if (classificacao == 1)

	Nbons++;

	Ntotal++;

	return;



}			



int seek_banco(char ref[])		/*devolve o indice do banco que se quer, NAO O OBJECTO BANCO*/



{	for (i = 0; i < Ntotal; i++)

		if !(strcmp(ref, index_bancos[i].referencia))

			return i;

}



int* actualiza_relacoes(int indice) /*indice do banco do qual se quer as relacoes*/

{



	int inP;	/*Num de Parceiros a quem o banco deve*/

	int outP;	/*Num de Parceios a quem o banco emprestou*/

	int outV;	/*Valor total que o banco emprestou*/

	int outVM;	/*Valor total que o banco emprestou a bancos maus*/

	int inV;	/*Valor total que o banco deve*/

	int inVM;	/*Valor total que o banco deve a bancos maus*/			/*determinar outP, outV e outVM*/



	int; 		/* variavel para os  indices dos outros bancos*/

	for (j = 1; j >= Nbancos; j++)
	{
		if relacional[indice][j] != 0
		{
			
 

}



void despromove_banco(int indice)

{

	index_bancos[indice].classificacao = '0';

	return;

}



void promove_banco(int indice)

{

	index_bancos[indice].classificacao = '1';

	return;

}



void empresta(int indice1, int indice2, int montante)

{

	relacional[indice1][indice2] += montante;

	return;

	/*FALTA A PARTE DOS PARCEIROS ETC*/

}



void amortiza(int indice1, int indice2, int montante)

{

	relacional[indice2][indice1] -= montante;
	return;

}


int despromove_pior(void)

{

	int valor_do_pior = 0;

	int indice_do_pior = 0;

	for (i = 0; i <= Ntotal; i++)

	{	

		valor_actual = index_bancos[i].inVM;

		if valor_actual => valor_do_pior

		{

			valor_do_pior = valor_actual;

			indice_do_pior = i;	

		}

	}

	if valor_do_pior != 0

		despromove_banco(indice_do_pior);

	return indice_do_pior;

}



void print_caracteristicas(int i, int tipo)

{

	string nome1 = bancos[i].nome

	string referencia1 = bancos[i].referencia

	string classificacao1 = bancos[i].classificacao

	printf("%s %s %s", nome1, referencia1, classificacao1);
	
	if (tipo)
	{
		int inP1 = bancos[i].inP

		int outP1 = bancos[i].outP

		int outV1 = bancos[i].outV

		int outVM1 = bancos[i].outVM

		int inV1 = bancos[i].inV

		int inVM1 = bancos[i].inVM

		printf(" %d %d %d %d %d %d", inP1, outP1, outV1, outVM1, inV1, inVM1);

	return;

}

void get_parametro(string linha)
{return strtok(linha, " ");}
